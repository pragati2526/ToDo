{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + \"You can either wrap \".concat(displayName, \" into a <div>, or turn it into a \") + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; // When passed a node, call the hook straight away.\n\n    if (!isValidElement(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return cloneWithRef(element, ref);\n  };\n}\n\nexport function wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      var wrappedHook = wrapHookToRecognizeElement(hook);\n\n      wrappedHooks[key] = function () {\n        return wrappedHook;\n      };\n    }\n  });\n  return wrappedHooks;\n}\n\nfunction setRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\n\nfunction cloneWithRef(element, newRef) {\n  var previousRef = element.ref;\n  invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return cloneElement(element, {\n      ref: newRef\n    });\n  } else {\n    return cloneElement(element, {\n      ref: function ref(node) {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/pragatisingh/Desktop/ToDo/ToDo/ToDo/node_modules/react-dnd/dist/esm/internals/wrapConnectorHooks.js"],"names":["invariant","cloneElement","isValidElement","throwIfCompositeComponentElement","element","type","displayName","name","Error","concat","wrapHookToRecognizeElement","hook","elementOrNode","arguments","length","undefined","options","node","ref","cloneWithRef","wrapConnectorHooks","hooks","wrappedHooks","Object","keys","forEach","key","endsWith","wrappedHook","setRef","current","newRef","previousRef"],"mappings":"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","sourcesContent":["import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + \"You can either wrap \".concat(displayName, \" into a <div>, or turn it into a \") + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    // When passed a node, call the hook straight away.\n    if (!isValidElement(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return cloneWithRef(element, ref);\n  };\n}\n\nexport function wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      var wrappedHook = wrapHookToRecognizeElement(hook);\n\n      wrappedHooks[key] = function () {\n        return wrappedHook;\n      };\n    }\n  });\n  return wrappedHooks;\n}\n\nfunction setRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\n\nfunction cloneWithRef(element, newRef) {\n  var previousRef = element.ref;\n  invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return cloneElement(element, {\n      ref: newRef\n    });\n  } else {\n    return cloneElement(element, {\n      ref: function ref(node) {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      }\n    });\n  }\n}"]},"metadata":{},"sourceType":"module"}